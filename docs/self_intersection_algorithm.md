# 相邻面检测算法文档

*更新日期: 2024-07-27 (V0.1.1)*

## 概述

相邻面检测算法是CFD项目的核心功能之一，用于检测模型中几何上邻近的三角形面片。V0.1.1版本对该算法的C++实现进行了重构，采用了新的邻近性判断标准。

## 算法原理 (V0.1.1)

相邻面检测算法基于以下关键步骤：

1.  **遍历面片对**: 对模型中所有唯一的面片对 (i, j) 进行检查。
2.  **计算几何属性**: 对每个面片，计算其质心 (Centroid) 和平均边长 (Average Edge Length, L)。
3.  **计算质心距离**: 计算两个面片质心之间的欧氏距离 `d`。
4.  **计算 Proximity**: 根据以下公式计算 Proximity 值 `P`：
    ```
    P = d / min(L_A, L_B)
    ```
    其中 `L_A` 和 `L_B` 分别是面片 i 和面片 j 的平均边长。
5.  **阈值判断**: 将计算出的 Proximity 值 `P` 与用户提供的 `proximity_threshold` 进行比较。
6.  **标记相邻**: 如果 `P <= proximity_threshold`，则将面片对 (i, j) 标记为相邻。

**关键变化 (V0.1.1 vs V0.1.0 及更早版本):**
*   **移除了相交检测**: V0.1.1 的相邻性判断**不再**基于几何相交测试 (如 Möller-Trumbore 算法)。
*   **移除了边界盒检测**: 由于不再进行相交测试，边界盒快速排除步骤也被移除。
*   **阈值意义改变**: `proximity_threshold` 不再用于与绝对距离或相对质心距离比较，而是直接作为 Proximity 值 `P` 的上限。
*   **判断依据**: 相邻性的唯一判断依据是 Proximity 公式和阈值。

## V0.0.9版本改进 (历史记录)

*注意：以下为 V0.0.9 的历史改进记录，部分内容可能已被 V0.1.1 的逻辑取代。*

### 1. 精确的点到三角形距离计算

新版本实现了更精确的点到三角形距离计算函数(`point_triangle_distance`)，包括：

- 处理退化三角形的特殊情况
- 使用重心坐标判断点的投影是否在三角形内部
- 计算点到三角形平面的距离
- 当投影不在三角形内部时，计算点到三角形边的最小距离

```python
def point_triangle_distance(self, point, triangle):
    """
    计算点到三角形的最小距离
    
    参数:
    point: 3D点坐标
    triangle: 由三个3D点组成的三角形
    
    返回:
    float: 点到三角形的最小距离
    """
    # 实现细节...
```

### 2. 精确的点到线段距离计算

新版本还提供了更精确的点到线段距离计算函数(`point_segment_distance`)，包括：

- 处理退化线段的特殊情况
- 计算点在线段上的投影
- 根据投影位置计算最小距离

```python
def point_segment_distance(self, p, a, b):
    """
    计算点到线段的最小距离
    
    参数:
    p: 点坐标
    a, b: 线段的两个端点
    
    返回:
    float: 点到线段的最小距离
    """
    # 实现细节...
```

### 3. 修复C++模块参数不匹配问题

V0.0.9版本修复了C++模块调用时的参数不匹配问题：

- 修正了Python和C++之间的数据类型转换
- 确保使用正确的numpy ndarray格式传递顶点和面片数据
- 提高了C++模块的兼容性和稳定性

## 性能对比 (基于 V0.1.0)

*注意: V0.1.1 修改了相邻面检测逻辑，以下性能数据可能不再准确，仅供参考。*

V0.0.9版本在性能方面取得了显著提升：

| 测试模型大小 | Python实现 | V0.0.8 C++实现 | V0.0.9 C++实现 |
|-------------|------------|----------------|----------------|
| 5千面片     | 3.5秒      | 0.15秒         | 0.12秒         |
| 5万面片     | 42秒       | 1.2秒          | 0.9秒          |
| 50万面片    | 超过10分钟  | 12秒           | 9秒            |

## 使用示例

```python
from src.mesh_viewer_qt import MeshViewerQt # 假设通过 UI 调用

# ... (加载 mesh_data) ...

# 在 MeshViewerQt 中点击"相邻面"按钮
# 输入 proximity_threshold (例如 0.1)

# 查看结果
# selected_faces 将包含所有满足 P <= threshold 的面片对中的面片索引
```
*注意: `proximity_threshold` 的取值范围和效果与旧版本不同，建议根据模型特点进行尝试。*

## 常见问题与解决方案

1.  **C++模块加载失败**
    *   确保已使用 `python setup.py build_ext --inplace` 成功编译 C++ 扩展。
    *   检查 Python 环境与编译模块是否兼容。

2.  **检测结果与预期不符 (V0.1.1)**
    *   理解新的 Proximity 公式 `P = d / min(L_A, L_B)`。
    *   尝试调整 `proximity_threshold`。较小的值要求质心距离相对于面片尺寸更小才算相邻。
    *   注意该逻辑不再检测几何相交。

3.  **检测速度慢**
    *   优先使用 C++ 实现。
    *   对于极大模型，此算法仍需遍历 N*(N-1)/2 对面片，计算量可能很大。

## 未来改进计划

1.  对 V0.1.1 的新相邻面检测逻辑进行性能基准测试。
2.  研究空间划分等优化手段以加速面片对的筛选过程。
3.  根据新的算法逻辑调整默认阈值或提供更直观的阈值设置建议。
4.  重新评估是否需要独立的几何相交检测功能。 